import { Option } from "../models/poll.js";
import { Poll } from "../models/poll.js";
import db from "../db/connection.js";
import { Request, Response } from "express";
import { ObjectId } from "mongodb";
import { Vote } from "../models/vote.js";

export async function createPoll(req: Request, res: Response) {
	const { title, options, endsAt } = req.body;

	// Create options array with ids.
	const optionsWithIds: Option[] = options.map(
		(option: string, index: number) => ({
			id: index.toString(),
			title: option,
		})
	);

	// Create the poll object.
	const createdAt = new Date();
	const document: Partial<Poll> = {
		title,
		options: optionsWithIds,
		createdAt,
		endsAt,
	};

	try {
		// Insert the document.
		let result = await db.collection("polls").insertOne(document);
		// Send back the objectID generated by MongoDB.
		res.status(201).send({ insertedId: result.insertedId });
	} catch (error) {
		res.status(500).send({
			message: "Error while trying to save the poll.",
		});
	}
}

export async function getPoll(req: Request, res: Response) {
	const pollId = req.params.id;

	try {
		const poll = await getPollForId(pollId);
		// Check if a poll was found.
		if (!poll) {
			return res.status(404).send({ message: "Poll not found." });
		}
		res.status(200).send(poll);
	} catch (error) {
		res.status(500).send({
			message: "An Error occured while fetching the poll.",
		});
	}
}

export async function getPollResults(req: Request, res: Response) {
	const pollId = req.params.id;

	try {
		const poll = await getPollForId(pollId);

		// Aggregate votes for each option.
		const aggregationPipeline = [
			{ $match: { poll_id: new ObjectId(pollId) } },
			{ $group: { _id: "$optionId", count: { $sum: 1 } } }, // Group votes by optionId and sum them.
			{ $project: { _id: 0, optionId: "$_id", count: 1 } }, // Remove the _id field and use it's value for the optionId field.
		];

		const pollResults = (await db
			.collection("votes")
			.aggregate(aggregationPipeline)
			.toArray()) as { optionId: string; count: number }[];

		res.status(200).send(pollResults);
	} catch (error) {
		res.status(500).send({
			message: "An Error occurred while fetching the poll results.",
		});
	}
}

export async function voteInPoll(req: Request, res: Response) {
	const clientIp = req.socket.remoteAddress;
	const pollId = req.params.id;
	const { optionId } = req.body;

	try {
		// Check if the poll exists.
		const poll = await getPollForId(pollId);
		if (!poll) {
			return res.status(404).send({ message: "Poll not found." });
		}

		// Check if the option exists.
		const option = poll.options.find((opt) => opt.id === optionId);
		if (!option) {
			return res.status(400).send({ message: "Invalid option." });
		}

		// Check for the clientIp in any existing Votes.
		const voteWithClientIp = await db
			.collection("votes")
			.findOne({ clientIp: clientIp });
		if (voteWithClientIp) {
			return res
				.status(403)
				.send({ message: "You can only vote once in this poll." });
		}

		// Create the Vote object.
		const voteDocument: Partial<Vote> = {
			poll_id: poll._id,
			optionId: option.id,
			createdAt: new Date(),
			clientIp: clientIp,
		};
		// Insert the document.
		let result = await db.collection("votes").insertOne(voteDocument);
		// Send back the objectID generated by MongoDB.
		res.status(201).send({ insertedId: result.insertedId });
	} catch (error) {
		res.status(500).send({
			message: "An Error occurred while recording the vote.",
		});
	}
}

async function getPollForId(id: string): Promise<Poll> {
	const query = { _id: new ObjectId(id) };
	const poll = await db.collection("polls").findOne(query);
	return poll as Poll;
}
